
TODO: what's wrong with making the /app folder a git repo..??

TODO: make a private git repo, and put the binary in it
  - this way i don't ever have to bother with set-up (or versions)!

TODO: setup company-dragonruby for emacs
  - copy configs
    - TODO: create a function for this
  - doom sync
  - test it out!
  - is it ordered?
    - (corfu +orderless +company) ; try removing +orderless in init?
    - corfu-sort-function?

https://discord.dragonruby.org
  - GO TO DISCORD

* docs
single file static local docs
  - file:///C:/Users/ra/my-stuff/repos/dragonruby-windows-amd64/docs/static/docs.html
  
* philosophy
TODO: read

* dev experience
** git repo setup

1. Your public repository needs only to contain the contents of ./mygame. This approach is the cleanest and doesn't require your .gitignore to be polluted with DragonRuby specific files.
2. edit .gitignore (see docs)
3. edit .gitgnore: add `/tmp/` and `/logs/`
  - NOTE: either:
    - keep a single folder of dragonruby and *just directly edit the repo in ./mygame*
      - then copy the folder to a seperate repo, per game, when you want to upload/push to git
    - *create a private repo with the binary and all*
      - ~100mb each
        - contains a lot of images for deploying to various platforms..
        - (dragonruby run-time is only 4mb tho..)
    
The DragonRuby binary/package is designed to be committed in its entirety with your source code (it’s why we keep it small). This protects the “shelf life” for commercial games. 3 years from now, we might be on a vastly different version of the engine. But you know that the code you’ve written will definitely work with the version that was committed to source control.

** the basics

/dragonruby/mygame/app/main.rb
  - the main entrance
    
/dragonruby/dragonruby
  - the executable

leave the game open as you are coding!
  - it will auto-pause/suspend
  - save the main.rb file to reload the updated game

** dev console

` or ~

you can explore the ruby program via the provided dev console
  - it has tab completion

if run via terminal, it seems to print output there too

** repl.rb

You can use DragonRuby's Console within the game to inspect object and execute small pieces of code. For more complex pieces of code create a file called repl.rb and put it in mygame/app/repl.rb:

Any code you write in there will be executed when you change the file. You can organize different pieces of code using the repl method:

#+begin_src ruby
repl do
  puts "hello world"
  puts 1 + 1
end

xrepl do
# use xrepl to "comment out" code
  puts "This code will not be executed because of the x in front of repl".
end
#+end_src

If you use the repl method, the code will be executed and the DragonRuby Console will automatically open so you can see the results (on Mac and Linux, the results will also be printed to the terminal). All puts statements will also be saved to logs/puts.txt. So if you want to stay in your editor and not look at the terminal, or the DragonRuby Console, you can tail this file. 4. To ignore code in repl.rb, instead of commenting it out, prefix repl with the letter x and it'll be ignored.
** debugging

"You can use DragonRuby's replay capabilities to troubleshoot:

DragonRuby is hot loaded which gives you a very fast feedback loop (if the game throws an exception, it's because of the code you just added). Use ./dragonruby mygame --record to create a game play recording that you can use to find the exception (you can replay a recording by executing ./dragonruby mygame --replay last_replay.txt or through the DragonRuby Console using $gtk.recording.start_replay "last_replay.txt".

DragonRuby also ships with a unit testing facility. You can invoke the following command to run a test: ./dragonruby mygame --test tests/some_ruby_file.rb. Get into the habit of adding debugging facilities within the game itself. You can add drawing primitives to args.outputs.debug that will render on top of your game but will be ignored in a production release.

Debugging something that runs at 60fps is (imo) not that helpful. The exception you are seeing could have been because of a change that occurred many frames ago."

** text editor setup

NOTE: i temporarily turned off ruby entirely in the .bashrc file using mise..

*** emacs company-mode

from ai:
Installing company-dragonruby in Doom Emacs and integrating it with corfu and cape involves several steps.

Enable company and corfu modules in Doom Emacs:
Open your ~/.doom.d/init.el file and ensure that the +company flag is enabled for the completion module, and the corfu module is also enabled.
Code

    (doom! :completion
           (corfu +company)
           ;; ... other completion modules
           )
Install company-dragonruby.
Add company-dragonruby to your ~/.doom.d/packages.el file.
Code

    (package! company-dragonruby)
Then, run doom sync in your terminal to install the package.
Configure corfu and cape to use company-dragonruby:
In your ~/.doom.d/config.el file, you need to configure cape to bridge company-dragonruby to completion-at-point-functions (CAPF), which corfu uses.
Code

    (after! company-dragonruby
      (add-to-list 'completion-at-point-functions
                   (cape-company-to-capf #'company-dragonruby)))
This code snippet ensures that after company-dragonruby is loaded, its completion capabilities are exposed to corfu via cape-company-to-capf. Reload Doom Emacs.
Restart Emacs for the changes to take effect. Now, when editing DragonRuby files, corfu should provide completions using company-dragonruby.

*** ctags
ctags for emacs (etags) and vim are included

NOTE: ALL of the completions are jumbled up.. :/. there is no object/module hierarchy to organize completions
  - everything is under GTK, or the module or class name (Sprite, Rect, etc.)
    - i mean, that's what the tags tables file shows.. if i'm reading it correctly..
  - shit, maybe a static lang is better..
  - *try zed(itor), just to quickly see what happens*
    - it's a pain to set up on this shitty chromebook, as it's gpu-oriented :/

M-x visit-tags-table
  - should be fine after that..

M-x select-tags-table
  - to see a list of tag paths stored..?

etags *.c *.h

etags $(find . -name \*.[ch]) --declarations
  - for sub-directories, looks for .c and .h (C) files
  - re-generate etags (ctags -e)
    - WARNING: not sure if this over-writes the orginal file..
      - the original file includes ctags for the runtime vars (GTK, etc.)

*** lsp

install the solargraph gem
get the dr yard docs repo
in mygame folder, run `solargraph config`
set up the relative directory to the yard docs repo and app folder

i recall it at least categorizing completions, with the current class's methods on top, then super/inherited objects below

but now, with the prism parser, surely there's a better one..??


#+begin_src ruby
$args. # NOT args.
  # triggers auto-complete
  # **all of DR's functions are here**

$args.gtk.
GTK.
  # this also works, but then you'd have to remember the name of the classes

args.state.player[:
  # triggers auto-complete
  # shows all keys for the current hash, then args.inputs, then args.outputs

# @params args [GTK::Args] # this tells solargraph a type hint
def tick args
  args.
    # triggers auto-complete
    # but at the moment, it only works within the function, and doesn't propogate the call stack
end
#+end_src

* code
** some notes from the tutorial

the main game loop: tick

#+begin_src ruby
def tick args
  # $game ||= Game.new
  $game.args = args # for attr_gtk macro
  $game.tick
end
#+end_src

"DragonRuby looks for this function and calls it every frame, 60 times a second..."

"Once your tick function finishes, we look at all the arrays you made (under outputs) and figure out how to draw it. You don't need to know about graphics APIs. You're just setting up some arrays! DragonRuby clears out these arrays every frame, so you just need to add what you need _right now_ each time."



60fps:

"One thing we decided to do in DragonRuby is not make you worry about delta time: your function runs at 60 frames per second (about 16 milliseconds) and that's that."

"Since we didn't make you worry about delta time, you can just move the rotation by 1 every time and it works without you having to keep track of time and math. Want it to move faster? Subtract 2."

** args

"'args' is a magic structure with lots of information in it. You can set variables in there for your own game state, and every frame it will updated if keys are pressed, joysticks moved, mice clicked, etc."

everything is in args

args.state
  # global state
  # use console to see what's inside interactively
  #   - type 'args', then press tab
  #     - same for gtk
  # args.state is a place you can hang your own data. It's an open data structure that allows you to define properties that are arbitrarily nested. You don't need to define any kind of class.
  - args.state.can.be.nested

"Want something to go away? Just don't add it to args.output anymore."
  
args.outputs.debug
  # output debug stuff here, probably doesn't go to production release
  
** some notes from the docs

If you want your game to run at full speed even when it's in the background, add the following line to mygame/metadata/cvars.txt:

renderer.background_sleep=0

** DR magicks

player[:x] = player[:x].add(dx).clamp(0)
  # "In DR specifically, Hashes have access semantics that look more like JavaScript objects: you can access (Symbol) keys either with square brackets or dot-notation. The rationale for this is that it makes the code change smaller when migrating from Hashes to Objects, with the bonus that dot-notation can actually be faster than the equivalent bracketed lookup." - pvande


entity = {
  x: ..
  y: ..
  ...
  head: { x: a.x, y: a.y, w: 5, h: 5, path: :pixel, r: 0, g: 255, b: 0}, # composition..??
}
  # can nest sprites/entities together
  
** secrets that can't be found via lsp
rand # global var?

sprite = { path: :pixel }
  # generates a pixel image

{x: 0, y: 0, w: 10, h: 10}.top/bottom/left/right
  # returns the length of a single side

1.to_radians/degrees

** optimal ways
# better to render via sprites instead of drawing api
#   - solids, borders, lines are debug objects and not meant for production, as they are drawn one pixel at a time..! lines can be used, but a sprite is still much better
** some more samples

NOTE: the samples should be more than enough..!

from discord:
...

amir's gist:
https://gist.github.com/amirrajan

https://github.com/kfischer-okarin/dragonruby-toolbox
https://github.com/kfischer-okarin/dragon_skeleton
https://github.com/kfischer-okarin/roguelike-base/

** ecs

#+begin_src ruby

# NOTE: don't worry about abstractions! just make the game!!

# amir's thoughts on ECS
,**my "entity" is a hash. and my component is keys on that hash.**
  - **start with this for entity architecture**

,**ecs in its simplest form is a function that operates on a hash with an assumed set of keys/properties**

# https://www.reddit.com/r/ruby/comments/v87oyx/comment/ibrq1w1/?utm_source=share&utm_medium=mweb3x&utm_name=mweb3xcss&utm_term=1&utm_content=share_button
#  - compare:
#    - https://github.com/DragonRuby/dragonruby-game-toolkit-contrib/blob/main/samples/99_genre_platformer/gorillas_basic/app/main.rb
#    - https://github.com/guitsaru/draco/tree/main/samples/gorillas-basic/app

# a few ECS architectures from the discord

# poor man's ECS by amir
def tick args
  args.state.entities ||= {}
  args.state.entities.player ||= {
    id: :player,
    x: 0,
    y: 0,
    w: 100,
    h: 100,
    path: "sprites/square/blue.png",
    systems: {
      drawable: true,
      moveable: true
    }
  }

  tick_movable_system args
  tick_drawable_system args
end

def tick_movable_system args
  entities_with_system(args, :moveable).each do |v|
    v.x += 1
    v.x = 0 if v.x > 1280
  end
end

def tick_drawable_system args
  args.outputs.primitives << entities_with_system(args, :drawable)
end

def entities_with_system args, system_name
  args.state
      .entities
      .values
      .find_all { |v| v.systems[system_name] }
end



# ECS using built-in language (no meta-programming?) by amir
class Entity
  def self.system_functions
    @system_functions ||= { }
    @system_functions
  end

  def tick args
    self.class.system_functions.each { |m, block| block.call args, self }
  end
end

module System
  def tick_method m, &block
    self.define_singleton_method :included { |base| base.system_functions[m] = block }
  end
end

module Drawable
  extend System

  attr :x, :y, :w, :h, :path

  tick_method :tick_drawable do |args, component|
    args.outputs.primitives << { x: component.x,
                                 y: component.y,
                                 w: component.w,
                                 h: component.h,
                                 path: component.path }
  end
end

module Movable
  extend System

  attr :x

  tick_method :tick_movable do |args, component|
    component.x += 1
  end
end

class Player < Entity
  include Drawable
  include Movable

  def initialize
    @x = 0
    @y = 0
    @w = 32
    @h = 32
    @path = 'sprites/square/blue.png'
  end
end

def tick args
  args.state.entities ||= [Player.new]
  args.state.entities.each { |e| e.tick args }
end

GTK.reset




# ECS in a much simpler way, by amir
class Draw
  def self.tick args, component
    args.outputs.primitives << { x: component.x,
                                 y: component.y,
                                 w: component.w,
                                 h: component.h,
                                 path: component.path }
  end
end

class Move
  def self.tick args, component
    component.x += 1
    component.x = 0 if component.x > 1280
  end
end

def tick args
  args.state.player ||= { x: 0, y: 0, w: 64, h: 64, path: 'sprites/square/blue.png' }
  Move.tick args, args.state.player
  Draw.tick args, args.state.player
end

GTK.reset



# a totally fine "ECS"
module Drawable
  attr :x, :y, :w, :h
end

class Player
  include Drawable
end

def render_system args, entity
  return if !entity.is_a? Drawable
  args.outputs.primitives << { x: entity.x ... }
end


# from kfischer-okarin
# https://github.com/kfischer-okarin/roguelike-base/blob/main/mygame/lib/component_definitions.rb
  class Component
    def initialize(name)
      @name = name
      @default_values = {}
      @attributes = {}
      @entity_attribute = {}
      @methods = {}
    end

    def attribute(name, default: nil)
      @default_values[name] = default if default
      @attributes[name] = true
    end

    def entity_attribute(name)
      @entity_attribute[name] = true
    end

    def method(name, &block)
      @methods[name] = block
    end

    def build_default_values
      DeepDup.dup(@default_values)
    end

    def attach_to(entity, **attributes)
      entity_component_data = entity.instance_variable_get(:@entity_component_data)
      component_data = entity_component_data[@name] = build_default_values.merge(attributes)

      @attributes.each_key do |name|
        entity.define_singleton_method(name) do
          component_data[name]
        end

        entity.define_singleton_method("#{name}=") do |value|
          component_data[name] = value
        end
      end

      @entity_attribute.each_key do |name|
        entity.define_singleton_method(name) do
          @entity_store[component_data[name]]
        end

        entity.define_singleton_method("#{name}=") do |value|
          component_data[name] = value.id
        end
      end

      @methods.each do |name, block|
        entity.define_singleton_method(name, &block)
      end
    end

    def to_s
      "Component(#{@name})"
    end
  end
end


class ComponentDefinitions
  def initialize
    @definitions = {}
  end

  def define(name, &block)
    component = Component.new(name)
    component.instance_eval(&block)
    @definitions[name] = component
  end

  def [](name)
    @definitions[name]
  end

  def defined_types
    @definitions.keys
  end

  def clear
    @definit
#+end_src


* amir's response about dynamic typing
# The way DR mitigates the lack of a static typing "feedback" is:
# hotloading with game state being retained
# built-in HUD/Quake Console
# args.outputs.watch https://docs.dragonruby.org/#/api/outputs?id=watch
# game play recording and replay https://docs.dragonruby.org/#/api/runtime?id=start_recording YouTube demo.d

# the (very real) benefits of dynamic typing:
# you are never waiting to start working again
# when in the prototyping phase, where you don't know what you're building yet, there's nothing asking you "but what are you building?!"
# in the event of an exception, the game is paused giving you a chance to introspect your game state
# extreme flexibilty, in a domain - game/artistic endeavors - where things simply don't fit into nice neat boxes
# significantly less code is written to accomplish the same task, hands down ^_^
* some design quotes from amir
**"Start your game as simply as possible. One file, one method (tick).**

**"A game is a body-of-state that goes through a pipeline of data transforms, and returns what should be rendered to the screen. Your single method will eventually become a collection of methods that are executed in order (it’s procedural in nature given that it’s a pipeline that transforms data/game state)."**

wrt incremental evolution: **a system in it's simplest form is a function that acts on data. that's what I start with**

**my "entity" is a hash. and my component is keys on that hash.**
  - **start with this for entity architecture**

**ecs in its simplest form is a function that operates on a hash with an assumed set of keys/properties**

















* TODO merge from notes.md
(the rest of this file)
* deploy
see docs
itch
mobile
  - only pro version

* args
args.outputs
  - draw things, append arrays with << operator
  
args.inputs

args.state
args.state.player[x:]
args.state.player.x
  - a place you can hang your own data. It's an open data structure that allows you to define properties that are arbitrarily nested. You don't need to define any kind of class.
  - it seems to be nested hashes
  - dot notation has the benefit of being easy to refactor if player evolves into a class
  - standard hash notation currently has the benefit of auto-complete working
  
args.geometry

args.cvars
 - Hash contains metadata pulled from the files under the ./metadata directory. To get the keys that are available type $args.cvars.keys in the Console.
   - args.cvars["game_metadata.version"].value.to_s

args.layout
  - Layout provides apis for placing primitives on a virtual grid that's within the "safe area" accross all platforms. This virtual grid is useful for rendering static controls (buttons, menu items, configuration screens, etc).

args.grid
  - Provides information about the screen and game canvas.
  
args.gtk
  - core runtime class
  - $gtk.function(...) or GTK.function(...)
    - or, if in the main tick, args.gtk.function
  - array (extensions)
      - **each**
      - map_2d
  - macros
    - attr = attr_accessor
    - **attr_gtk** passing args for you
  - contains a bunch of environment/utility functions, SDL stuff, etc.
    - window related stuff
    - mouse related stuff
    - request_quit / quit_requested?
    - platform?
    - exec
      - Given an OS dependent cli command represented as a string, this function executes the command and returns a string representing the results.
        - **connect the shell to DR!!**
    - system
      - same as above, but put outputs to the console (returns nil)
  - file i/o
    - within the same directory as the the dragonruby binary
  - network i/o
    - start a http server..!
  - dev support functions
    - lots..!
    - use these in the dev console
    - reset
    - slowmo!
    - replay
    - recording
    - ..hopefully there's autocomplete..!
    
* troubleshoot performance
TODO: though shouldn't pre-optimize, def need to know some good habits







* getting started / tutorial
TODO: can extract the important bits out later, once i'm more comfy with the engine and language


* hello world
* game loop/stick runs 60 frames/second

```ruby
* in main.rb
def tick args
  args.outputs.labels << [580, 400, 'Hello World!']
end
```

this is all you need to have a game!! hoooolyyyy shiiiiiitttt!!! :mind_explosion:

"args" is a magic structure with lots of information in it. You can set variables in there for your own game state, and every frame it will updated if keys are pressed, joysticks moved, mice clicked, etc.

the game uses the outputs object to draw things. you use arrays to draw things. in this case [x, y, text]

The "<<" thing says "append this array onto the list of them at args.outputs.labels)

Once your tick function finishes, we look at all the arrays you made and figure out how to draw it. You don't need to know about graphics APIs. You're just setting up some arrays! DragonRuby clears out these arrays every frame, so you just need to add what you need _right now_ each time.




* sprites
Each 2D image in DragonRuby is called a "sprite," and to use them, you just make sure they exist in a reasonable file format (png, jpg, gif, bmp, etc) and specify them by filename. The first time you use one, DragonRuby will load it and keep it in video memory for fast access in the future. If you use a filename that doesn't exist, you get a fun checkerboard pattern!

```ruby
def tick args
  args.outputs.labels  << [580, 400, 'Hello World!']
  args.outputs.sprites << [576, 100, 128, 101, 'dragonruby.png']
end
```


NOTE: when you save main.rb, DragonRuby will notice and reload your program.

That .sprites line says "add a sprite to the list of sprites we're drawing, and draw it at position (576, 100) at a size of 128x101 pixels". You can find the image to draw at dragonruby.png.




* coordinates
**(0, 0) is the bottom left corner of the screen, and positive numbers go up and to the right.** This is more "geometrically correct," even if it's not how you remember doing 2D graphics, but we chose this for a simpler reason: when you're making Super Mario Brothers and you want Mario to jump, you should be able to add to Mario's y position as he goes up and subtract as he falls. It makes things easier to understand.
  - yesssss!!! love this reasoning! design > formalisms

**your game screen is _always_ 1280x720 pixels.** If you resize the window, we will scale and letterbox everything appropriately, so you never have to worry about different resolutions.

``` ruby
def tick args
  args.state.rotation  ||= 0
  args.outputs.labels  << [580, 400, 'Hello World!' ]
  args.outputs.sprites << [576, 100, 128, 101, 'dragonruby.png', args.state.rotation]
  args.state.rotation  -= 1
end
```

**args.state is a place you can hang your own data.** It's an open data structure that allows you to define properties that are arbitrarily nested. You don't need to define any kind of class.

In this case, the current rotation of our sprite, which is happily spinning at 60 frames per second. If you don't specify rotation (or alpha, or color modulation, or a source rectangle, etc), **DragonRuby picks a reasonable default,** and **the array is ordered by the most likely things you need to tell us:** position, size, name.



* there is no delta time
One thing we decided to do in DragonRuby is not make you worry about delta time: **your function runs at 60 frames per second (about 16 milliseconds) and that's that.** Having to worry about framerate is something massive triple-AAA games do, but for fun little 2D games? You'd have to work really hard to not hit 60fps. All your drawing is happening on a GPU designed to run Fortnite quickly; it can definitely handle this.

Since we didn't make you worry about delta time, you can just move the rotation by 1 every time and it works without you having to keep track of time and math. Want it to move faster? Subtract 2.
  - hmmmm, interesting choice..



* handle user input
```ruby
def tick args
  args.state.rotation ||= 0
  args.state.x ||= 576 # default
  args.state.y ||= 100

  if args.inputs.mouse.click
    args.state.x = args.inputs.mouse.click.point.x - 64
    args.state.y = args.inputs.mouse.click.point.y - 50
  end

  args.outputs.labels  << [580, 400, 'Hello World!']
  args.outputs.sprites << [args.state.x,
                           args.state.y,
                           128,
                           101,
                           'dragonruby.png',
                           args.state.rotation]

  args.state.rotation -= 1
end
```

Everywhere you click your mouse, the image moves there. We set a default location for it with args.state.x ||= 576, and then we change those variables when we see the mouse button in action. You can get at the keyboard and game controllers in similar ways.

